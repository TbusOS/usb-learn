# USBé©±åŠ¨å¼€å‘å¸¸è§é—®é¢˜è§£ç­” (FAQ)

## ğŸ“‹ ç›®å½•

æœ¬æ–‡æ¡£æ”¶é›†äº†USBé©±åŠ¨å¼€å‘ä¸­æœ€å¸¸è§çš„é—®é¢˜ï¼ŒæŒ‰ç…§ç±»åˆ«ç»„ç»‡ï¼š

1. **åŸºç¡€æ¦‚å¿µé—®é¢˜**
2. **é©±åŠ¨å¼€å‘é—®é¢˜**
3. **è°ƒè¯•é—®é¢˜**
4. **æ€§èƒ½é—®é¢˜**
5. **å…¼å®¹æ€§é—®é¢˜**
6. **é”™è¯¯å¤„ç†é—®é¢˜**

---

## 1. åŸºç¡€æ¦‚å¿µé—®é¢˜

### Q1.1: USBçš„å››ç§ä¼ è¾“ç±»å‹è¯¥å¦‚ä½•é€‰æ‹©ï¼Ÿ

**ç­”æ¡ˆ**ï¼š
```
ä¼ è¾“ç±»å‹é€‰æ‹©æŒ‡å—ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä¼ è¾“ç±»å‹   â”‚   ä½¿ç”¨åœºæ™¯    â”‚    ç‰¹ç‚¹      â”‚   å…¸å‹è®¾å¤‡    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ§åˆ¶ä¼ è¾“   â”‚ è®¾å¤‡é…ç½®     â”‚ å¯é ã€åŒå‘   â”‚ æ‰€æœ‰è®¾å¤‡     â”‚
â”‚            â”‚ å‘½ä»¤å‘é€     â”‚ å¸¦å®½æœ‰é™     â”‚              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ‰¹é‡ä¼ è¾“   â”‚ å¤§é‡æ•°æ®     â”‚ å¯é         â”‚ Uç›˜ã€æ‰“å°æœº  â”‚
â”‚            â”‚ æ— æ—¶é—´è¦æ±‚   â”‚ æ— å¸¦å®½ä¿è¯   â”‚              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ä¸­æ–­ä¼ è¾“   â”‚ å°‘é‡æ•°æ®     â”‚ ä½å»¶è¿Ÿ      â”‚ é¼ æ ‡ã€é”®ç›˜   â”‚
â”‚            â”‚ å®šæœŸä¼ è¾“     â”‚ å¸¦å®½ä¿è¯     â”‚              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åŒæ­¥ä¼ è¾“   â”‚ å®æ—¶æ•°æ®     â”‚ å¸¦å®½ä¿è¯    â”‚ éŸ³é¢‘ã€è§†é¢‘   â”‚
â”‚            â”‚ æµåª’ä½“       â”‚ æ— é‡ä¼       â”‚ æ‘„åƒå¤´      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Q1.2: ä¸ºä»€ä¹ˆUSBè®¾å¤‡æœ‰æ—¶æšä¸¾å¤±è´¥ï¼Ÿ

**ç­”æ¡ˆ**ï¼š
å¸¸è§åŸå› åŠè§£å†³æ–¹æ³•ï¼š

1. **ç”µæºé—®é¢˜**
   - ä¾›ç”µä¸è¶³ï¼šæ£€æŸ¥æ˜¯å¦è¶…è¿‡Hubçš„ä¾›ç”µèƒ½åŠ›(500mA for USB 2.0)
   - è§£å†³ï¼šä½¿ç”¨å¸¦ç”µæºçš„Hubæˆ–ç›´è¿ä¸»æœº

2. **æè¿°ç¬¦é”™è¯¯**
   - æè¿°ç¬¦æ ¼å¼é”™è¯¯æˆ–ä¸å®Œæ•´
   - è§£å†³ï¼šæ£€æŸ¥æè¿°ç¬¦çš„bLengthå’ŒbDescriptorTypeå­—æ®µ

3. **æ—¶åºé—®é¢˜**
   - è®¾å¤‡å“åº”è¶…æ—¶
   - è§£å†³ï¼šå¢åŠ æšä¸¾å»¶è¿Ÿï¼Œæ£€æŸ¥å›ºä»¶å“åº”æ—¶é—´

4. **çº¿ç¼†é—®é¢˜**
   - çº¿ç¼†è´¨é‡å·®æˆ–è¿‡é•¿
   - è§£å†³ï¼šä½¿ç”¨é«˜è´¨é‡çŸ­çº¿ç¼†

### Q1.3: USBè®¾å¤‡åœ°å€æ˜¯å¦‚ä½•åˆ†é…çš„ï¼Ÿ

**ç­”æ¡ˆ**ï¼š
```
åœ°å€åˆ†é…è¿‡ç¨‹ï¼š
1. è®¾å¤‡åˆšè¿æ¥æ—¶ä½¿ç”¨åœ°å€0ï¼ˆé»˜è®¤åœ°å€ï¼‰
2. ä¸»æœºé€šè¿‡SET_ADDRESSå‘½ä»¤åˆ†é…å”¯ä¸€åœ°å€(1-127)
3. åœ°å€0ä¿ç•™ç»™æ–°è¿æ¥çš„è®¾å¤‡ä½¿ç”¨
4. ä¸»æœºç»´æŠ¤åœ°å€åˆ†é…è¡¨ï¼Œç¡®ä¿ä¸é‡å¤
```

---

## 2. é©±åŠ¨å¼€å‘é—®é¢˜

### Q2.1: probeå‡½æ•°ä¸è¢«è°ƒç”¨æ€ä¹ˆåŠï¼Ÿ

**ç­”æ¡ˆ**ï¼š
æ£€æŸ¥æ¸…å•ï¼š

```c
// 1. æ£€æŸ¥è®¾å¤‡IDè¡¨æ˜¯å¦æ­£ç¡®
static const struct usb_device_id my_id_table[] = {
    { USB_DEVICE(0x1234, 0x5678) },  // VIDå’ŒPIDè¦åŒ¹é…
    { }  // å¿…é¡»æœ‰ç»ˆæ­¢ç¬¦ï¼
};
MODULE_DEVICE_TABLE(usb, my_id_table);  // ä¸è¦å¿˜è®°è¿™è¡Œ

// 2. æ£€æŸ¥é©±åŠ¨æ˜¯å¦æ­£ç¡®æ³¨å†Œ
static struct usb_driver my_driver = {
    .name = "my_driver",
    .probe = my_probe,        // ç¡®ä¿å‡½æ•°åæ­£ç¡®
    .disconnect = my_disconnect,
    .id_table = my_id_table,  // ç¡®ä¿å…³è”IDè¡¨
};

// 3. æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–é©±åŠ¨å·²ç»ç»‘å®š
// ä½¿ç”¨ lsusb -t æŸ¥çœ‹è®¾å¤‡æ˜¯å¦å·²è¢«å…¶ä»–é©±åŠ¨å ç”¨
// å¦‚éœ€è§£ç»‘ï¼šecho -n "1-1:1.0" > /sys/bus/usb/drivers/xxx/unbind
```

### Q2.2: URBæäº¤æ€»æ˜¯è¿”å›é”™è¯¯æ€ä¹ˆåŠï¼Ÿ

**ç­”æ¡ˆ**ï¼š
å¸¸è§é”™è¯¯ç åŠè§£å†³ï¼š

```c
int ret = usb_submit_urb(urb, GFP_KERNEL);
switch (ret) {
case -EINVAL:
    // URBå‚æ•°æ— æ•ˆ
    // æ£€æŸ¥ï¼šç«¯ç‚¹æ–¹å‘ã€ä¼ è¾“ç±»å‹ã€ç¼“å†²åŒºå¤§å°
    break;
    
case -ENODEV:
    // è®¾å¤‡å·²æ–­å¼€
    // æ£€æŸ¥ï¼šè®¾å¤‡æ˜¯å¦è¿˜è¿æ¥ç€
    break;
    
case -EPIPE:
    // ç«¯ç‚¹åœæ­¢(STALL)
    // è§£å†³ï¼šusb_clear_halt()æ¸…é™¤åœæ­¢çŠ¶æ€
    break;
    
case -ENOMEM:
    // å†…å­˜ä¸è¶³
    // è§£å†³ï¼šæ£€æŸ¥ç³»ç»Ÿå†…å­˜ï¼Œå‡å°‘URBæ•°é‡
    break;
}
```

### Q2.3: å¦‚ä½•å¤„ç†USBçƒ­æ’æ‹”ï¼Ÿ

**ç­”æ¡ˆ**ï¼š
```c
// æ­£ç¡®çš„çƒ­æ’æ‹”å¤„ç†æ¨¡å¼
static int my_probe(struct usb_interface *intf, 
                   const struct usb_device_id *id)
{
    struct my_device *dev;
    
    // 1. åˆ†é…å¹¶åˆå§‹åŒ–è®¾å¤‡ç»“æ„
    dev = kzalloc(sizeof(*dev), GFP_KERNEL);
    
    // 2. ä¿å­˜æ¥å£æŒ‡é’ˆï¼ˆé‡è¦ï¼ï¼‰
    dev->interface = intf;
    usb_set_intfdata(intf, dev);
    
    // 3. è·å–USBè®¾å¤‡å¼•ç”¨
    dev->udev = usb_get_dev(interface_to_usbdev(intf));
    
    return 0;
}

static void my_disconnect(struct usb_interface *intf)
{
    struct my_device *dev = usb_get_intfdata(intf);
    
    // 1. é˜²æ­¢æ–°çš„I/Oæ“ä½œ
    usb_set_intfdata(intf, NULL);
    
    // 2. å–æ¶ˆæ‰€æœ‰pendingçš„URB
    usb_kill_anchored_urbs(&dev->submitted);
    
    // 3. ç­‰å¾…æ‰€æœ‰I/Oå®Œæˆ
    mutex_lock(&dev->io_mutex);
    dev->disconnected = 1;
    mutex_unlock(&dev->io_mutex);
    
    // 4. é‡Šæ”¾USBè®¾å¤‡å¼•ç”¨
    usb_put_dev(dev->udev);
    
    // 5. é‡Šæ”¾èµ„æº
    kfree(dev);
}
```

---

## 3. è°ƒè¯•é—®é¢˜

### Q3.1: å¦‚ä½•æŸ¥çœ‹USBæ•°æ®åŒ…å†…å®¹ï¼Ÿ

**ç­”æ¡ˆ**ï¼š
å¤šç§æ–¹æ³•ï¼š

```bash
# æ–¹æ³•1ï¼šä½¿ç”¨usbmon
sudo modprobe usbmon
sudo cat /sys/kernel/debug/usb/usbmon/0u

# æ–¹æ³•2ï¼šä½¿ç”¨Wireshark
sudo modprobe usbmon
sudo wireshark
# é€‰æ‹©usbmon0æ¥å£

# æ–¹æ³•3ï¼šåœ¨é©±åŠ¨ä¸­æ‰“å°
static void print_urb_data(struct urb *urb)
{
    print_hex_dump(KERN_DEBUG, "URB Data: ",
                   DUMP_PREFIX_OFFSET, 16, 1,
                   urb->transfer_buffer,
                   urb->actual_length, true);
}
```

### Q3.2: é©±åŠ¨åŠ è½½åè®¾å¤‡æ— å“åº”ï¼Ÿ

**ç­”æ¡ˆ**ï¼š
è°ƒè¯•æ­¥éª¤ï¼š

```bash
# 1. æ£€æŸ¥é©±åŠ¨æ˜¯å¦åŠ è½½
lsmod | grep your_driver

# 2. æ£€æŸ¥è®¾å¤‡æ˜¯å¦è¢«è¯†åˆ«
lsusb -v -d vid:pid

# 3. æŸ¥çœ‹å†…æ ¸æ—¥å¿—
dmesg | tail -n 50

# 4. æ£€æŸ¥è®¾å¤‡ç»‘å®šçŠ¶æ€
ls -l /sys/bus/usb/devices/*/driver

# 5. å¯ç”¨è°ƒè¯•ä¿¡æ¯
echo 'module your_driver +p' > /sys/kernel/debug/dynamic_debug/control

# 6. æ£€æŸ¥URBçŠ¶æ€
cat /sys/kernel/debug/usb/devices
```

### Q3.3: å¦‚ä½•å®šä½å†…å­˜æ³„æ¼ï¼Ÿ

**ç­”æ¡ˆ**ï¼š
```c
// ä½¿ç”¨å†…æ ¸å†…å­˜è°ƒè¯•å·¥å…·

// 1. é…ç½®å†…æ ¸é€‰é¡¹
CONFIG_DEBUG_KMEMLEAK=y

// 2. è¿è¡Œæ—¶æ£€æµ‹
echo scan > /sys/kernel/debug/kmemleak
cat /sys/kernel/debug/kmemleak

// 3. åœ¨ä»£ç ä¸­æ·»åŠ æ£€æŸ¥
static void check_memory_leak(void)
{
    // æ¯æ¬¡åˆ†é…éƒ½è¦æœ‰å¯¹åº”çš„é‡Šæ”¾
    // probeä¸­åˆ†é… -> disconnectä¸­é‡Šæ”¾
    // openä¸­åˆ†é… -> releaseä¸­é‡Šæ”¾
    // submit_urb -> free_urb
}

// 4. ä½¿ç”¨å¼•ç”¨è®¡æ•°
struct my_device {
    struct kref kref;
    // ...
};

static void my_delete(struct kref *kref)
{
    struct my_device *dev = container_of(kref, 
                                        struct my_device, kref);
    kfree(dev);
}
```

---

## 4. æ€§èƒ½é—®é¢˜

### Q4.1: USBä¼ è¾“é€Ÿåº¦è¾¾ä¸åˆ°ç†è®ºå€¼ï¼Ÿ

**ç­”æ¡ˆ**ï¼š
æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥è¡¨ï¼š

```
1. ä½¿ç”¨æ­£ç¡®çš„ä¼ è¾“ç±»å‹
   - æ‰¹é‡ä¼ è¾“ç”¨äºå¤§æ•°æ®
   - ä¸è¦ç”¨æ§åˆ¶ä¼ è¾“ä¼ å¤§é‡æ•°æ®

2. å¢å¤§ä¼ è¾“ç¼“å†²åŒº
   - USB 2.0: ä½¿ç”¨512å­—èŠ‚
   - USB 3.0: ä½¿ç”¨1024å­—èŠ‚æˆ–æ›´å¤§

3. ä½¿ç”¨å¤šä¸ªURBé˜Ÿåˆ—
   - é¿å…ä¼ è¾“é—´éš™
   - å…¸å‹ä½¿ç”¨4-8ä¸ªURB

4. ä½¿ç”¨é›¶æ‹·è´æŠ€æœ¯
   - URB_NO_TRANSFER_DMA_MAP
   - é¢„åˆ†é…DMAç¼“å†²åŒº

5. æ£€æŸ¥USBæ ‘ç»“æ„
   - é¿å…é€šè¿‡å¤šå±‚Hub
   - æ£€æŸ¥æ˜¯å¦é™é€Ÿè¿è¡Œ
```

### Q4.2: å¦‚ä½•ä¼˜åŒ–URBé˜Ÿåˆ—ï¼Ÿ

**ç­”æ¡ˆ**ï¼š
```c
#define URB_COUNT 4

struct urb_queue {
    struct urb *urbs[URB_COUNT];
    struct usb_anchor submitted;
};

// åˆå§‹åŒ–å¤šä¸ªURB
static int init_urb_queue(struct urb_queue *queue)
{
    int i;
    
    init_usb_anchor(&queue->submitted);
    
    for (i = 0; i < URB_COUNT; i++) {
        queue->urbs[i] = usb_alloc_urb(0, GFP_KERNEL);
        // å¡«å……URBå‚æ•°
        usb_fill_bulk_urb(...);
        // æäº¤URB
        usb_anchor_urb(queue->urbs[i], &queue->submitted);
        usb_submit_urb(queue->urbs[i], GFP_KERNEL);
    }
    
    return 0;
}

// URBå®Œæˆåç«‹å³é‡æ–°æäº¤
static void urb_complete(struct urb *urb)
{
    // å¤„ç†æ•°æ®
    process_data(urb);
    
    // é‡æ–°æäº¤
    usb_submit_urb(urb, GFP_ATOMIC);
}
```

---

## 5. å…¼å®¹æ€§é—®é¢˜

### Q5.1: é©±åŠ¨åœ¨ä¸åŒå†…æ ¸ç‰ˆæœ¬ä¸å…¼å®¹ï¼Ÿ

**ç­”æ¡ˆ**ï¼š
```c
// ä½¿ç”¨å†…æ ¸ç‰ˆæœ¬å®å¤„ç†å…¼å®¹æ€§
#include <linux/version.h>

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
    // 5.0+ç‰ˆæœ¬çš„ä»£ç 
    static unsigned int my_poll(struct file *file, poll_table *wait)
#else
    // æ—§ç‰ˆæœ¬çš„ä»£ç 
    static unsigned int my_poll(struct file *file, 
                               struct poll_table_struct *wait)
#endif
{
    // å‡½æ•°å®ç°
}

// å¸¸è§APIå˜åŒ–å¤„ç†
#if LINUX_VERSION_CODE < KERNEL_VERSION(4,13,0)
    #define usb_endpoint_maxp(ep) \
        le16_to_cpu((ep)->desc.wMaxPacketSize)
#endif
```

### Q5.2: è®¾å¤‡åœ¨Windowså·¥ä½œä½†Linuxä¸å·¥ä½œï¼Ÿ

**ç­”æ¡ˆ**ï¼š
å¯èƒ½åŸå› ï¼š

1. **åˆå§‹åŒ–åºåˆ—ä¸åŒ**
   - Windowså¯èƒ½å‘é€ç‰¹å®šçš„å‚å•†å‘½ä»¤
   - è§£å†³ï¼šä½¿ç”¨usbmonæŠ“å–Windowsä¸‹çš„åˆå§‹åŒ–åºåˆ—

2. **ç«¯ç‚¹ä½¿ç”¨ä¸åŒ**
   - æ£€æŸ¥Windowsé©±åŠ¨ä½¿ç”¨å“ªäº›ç«¯ç‚¹
   - ä½¿ç”¨USBViewæˆ–ç±»ä¼¼å·¥å…·æŸ¥çœ‹

3. **ç”µæºç®¡ç†å·®å¼‚**
   - Linuxé»˜è®¤å¯ç”¨autosuspend
   - æµ‹è¯•ï¼š`echo on > /sys/bus/usb/devices/.../power/control`

---

## 6. é”™è¯¯å¤„ç†é—®é¢˜

### Q6.1: è®¾å¤‡è¿”å›STALLè¯¥æ€ä¹ˆå¤„ç†ï¼Ÿ

**ç­”æ¡ˆ**ï¼š
```c
// STALLå¤„ç†æµç¨‹
static int handle_stall(struct usb_device *udev, int pipe)
{
    int ret;
    
    // 1. æ¸…é™¤ç«¯ç‚¹STALLçŠ¶æ€
    ret = usb_clear_halt(udev, pipe);
    if (ret < 0) {
        dev_err(&udev->dev, "æ¸…é™¤STALLå¤±è´¥: %d\n", ret);
        
        // 2. å¦‚æœæ¸…é™¤å¤±è´¥ï¼Œå°è¯•å¤ä½ç«¯ç‚¹
        ret = usb_reset_endpoint(udev, pipe);
        if (ret < 0) {
            // 3. æœ€åæ‰‹æ®µï¼šå¤ä½è®¾å¤‡
            ret = usb_reset_device(udev);
        }
    }
    
    return ret;
}
```

### Q6.2: å¦‚ä½•å¤„ç†è®¾å¤‡æ— å“åº”ï¼ˆè¶…æ—¶ï¼‰ï¼Ÿ

**ç­”æ¡ˆ**ï¼š
```c
// è¶…æ—¶å¤„ç†ç­–ç•¥
static int robust_transfer(struct usb_device *udev, 
                         void *data, int len)
{
    int ret;
    int retry = 3;
    int timeout = 5000;  // 5ç§’
    
    while (retry--) {
        ret = usb_bulk_msg(udev, pipe, data, len, 
                          &actual_len, timeout);
        
        if (ret == -ETIMEDOUT) {
            dev_warn(&udev->dev, "è¶…æ—¶ï¼Œé‡è¯• %d\n", retry);
            
            // å¢åŠ è¶…æ—¶æ—¶é—´
            timeout += 5000;
            
            // å¯é€‰ï¼šå‘é€è®¾å¤‡å¤ä½
            if (retry == 1) {
                usb_reset_endpoint(udev, pipe);
            }
            
            continue;
        }
        
        break;  // æˆåŠŸæˆ–å…¶ä»–é”™è¯¯
    }
    
    return ret;
}
```

### Q6.3: è®¾å¤‡æ„å¤–æ–­å¼€å¦‚ä½•ä¼˜é›…å¤„ç†ï¼Ÿ

**ç­”æ¡ˆ**ï¼š
```c
// ä¼˜é›…å¤„ç†æ–­å¼€è¿æ¥
static void graceful_disconnect(struct my_device *dev)
{
    // 1. è®¾ç½®æ–­å¼€æ ‡å¿—ï¼ˆé˜²æ­¢æ–°I/Oï¼‰
    atomic_set(&dev->disconnected, 1);
    
    // 2. å”¤é†’æ‰€æœ‰ç­‰å¾…çš„çº¿ç¨‹
    wake_up_interruptible(&dev->wait_queue);
    
    // 3. å–æ¶ˆæ‰€æœ‰URB
    usb_kill_anchored_urbs(&dev->submitted);
    
    // 4. ç­‰å¾…æ­£åœ¨è¿›è¡Œçš„æ“ä½œå®Œæˆ
    mutex_lock(&dev->io_mutex);
    while (atomic_read(&dev->ongoing_io) > 0) {
        mutex_unlock(&dev->io_mutex);
        msleep(10);
        mutex_lock(&dev->io_mutex);
    }
    mutex_unlock(&dev->io_mutex);
    
    // 5. æ¸…ç†èµ„æº
    cleanup_resources(dev);
}
```

---

## å¿«é€Ÿæ•…éšœæ’é™¤æµç¨‹å›¾

```
                USBé©±åŠ¨æ•…éšœæ’é™¤æµç¨‹
                
é—®é¢˜å‘ç”Ÿ
    â”‚
    â–¼
è®¾å¤‡æ˜¯å¦è¢«è¯†åˆ«ï¼Ÿâ”€â”€å¦â”€â”€> æ£€æŸ¥ï¼šç¡¬ä»¶è¿æ¥ã€VID/PIDã€dmesgæ—¥å¿—
    â”‚æ˜¯
    â–¼
é©±åŠ¨æ˜¯å¦åŠ è½½ï¼Ÿâ”€â”€â”€â”€å¦â”€â”€> æ£€æŸ¥ï¼šlsmodã€modprobeã€å†…æ ¸é…ç½®
    â”‚æ˜¯
    â–¼
probeæ˜¯å¦è°ƒç”¨ï¼Ÿâ”€â”€â”€å¦â”€â”€> æ£€æŸ¥ï¼šIDè¡¨ã€å…¶ä»–é©±åŠ¨å ç”¨ã€ç»‘å®šçŠ¶æ€
    â”‚æ˜¯
    â–¼
URBæ˜¯å¦æˆåŠŸï¼Ÿâ”€â”€â”€â”€â”€å¦â”€â”€> æ£€æŸ¥ï¼šç«¯ç‚¹é…ç½®ã€ä¼ è¾“ç±»å‹ã€é”™è¯¯ç 
    â”‚æ˜¯
    â–¼
æ•°æ®æ˜¯å¦æ­£ç¡®ï¼Ÿâ”€â”€â”€â”€å¦â”€â”€> æ£€æŸ¥ï¼šusbmonæŠ“åŒ…ã€æ•°æ®æ ¼å¼ã€æ—¶åº
    â”‚æ˜¯
    â–¼
æ€§èƒ½æ˜¯å¦æ»¡è¶³ï¼Ÿâ”€â”€â”€â”€å¦â”€â”€> ä¼˜åŒ–ï¼šURBé˜Ÿåˆ—ã€ç¼“å†²åŒºå¤§å°ã€DMA
    â”‚æ˜¯
    â–¼
é—®é¢˜è§£å†³
```

---

## æ€»ç»“

USBé©±åŠ¨å¼€å‘ä¸­çš„é—®é¢˜é€šå¸¸é›†ä¸­åœ¨ï¼š

1. **è®¾å¤‡è¯†åˆ«å’Œæšä¸¾**ï¼šç¡®ä¿æè¿°ç¬¦å’ŒIDåŒ¹é…æ­£ç¡®
2. **æ•°æ®ä¼ è¾“**ï¼šé€‰æ‹©æ­£ç¡®çš„ä¼ è¾“ç±»å‹å’Œç«¯ç‚¹
3. **é”™è¯¯å¤„ç†**ï¼šä¼˜é›…å¤„ç†å„ç§å¼‚å¸¸æƒ…å†µ
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šä½¿ç”¨å¤šURBå’ŒDMAæé«˜æ•ˆç‡
5. **è°ƒè¯•æŠ€å·§**ï¼šå–„ç”¨usbmonå’Œå†…æ ¸æ—¥å¿—

è®°ä½ï¼šå¤§å¤šæ•°USBé—®é¢˜éƒ½å¯ä»¥é€šè¿‡ä»”ç»†æŸ¥çœ‹`dmesg`æ—¥å¿—å’Œ`usbmon`æŠ“åŒ…æ¥å®šä½ï¼
